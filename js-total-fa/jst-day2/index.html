<!doctype html>
<html lang="fr">

  <head>
    <meta charset="utf-8">
    <title>JS Total • 2ème partie, 15/12/2015</title>

    <meta name="author" content="Christophe Porteneuve">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/js-attitude.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/tomorrow.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      if (window.location.search.match( /print-pdf/gi))
        document.write( '<link rel="stylesheet" href="css/print/pdf.css" type="text/css" media="all">' );
      else
        document.write( '<link rel="stylesheet" href="css/print/paper.css" type="text/css" media="print">' );;
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body class="no-anims">

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section id="intro">
          <h1>JS Total</h1>
          <h3 data-marker="intro-date">2ème partie, 15/12/2015</h3>
          <h4 data-marker="intro-trainers">Jonathan Blanchet @ JS Attitude</h4>
          <script>
            // Delicously hacky. Look away.
            if( navigator.userAgent.match( /(iPhone|iPad|iPod|Android)/i ) ) document.write( '<p style="color: rgba(0,0,0,0.3); text-shadow: none;">('+'Tap to navigate'+')</p>' );
          </script>
          <aside class="notes" data-markdown>
            slides sur http://delicious-insights.com/js-total/jst-day2/
          </aside>
        </section>

        <section id="overview">
          <h1>JS Total</h1>
          <h4 data-marker="overview-dates">3 journées du 14 au 16 décembre</h4>

          <ol>
            <li><span data-marker="day2">Aujourd’hui</span> : Outils, DevTools, modules et début SPA</li>
            <li><span data-marker="day3">Demain</span> : développement d’une SPA complète, tests</li>
          </ol>
          <aside class="notes" data-markdown>
            slides sur http://delicious-insights.com/js-total/jst-day2/
          </aside>
        </section>

        <section id="debug-consoles">
          <section class="chapter">
            <h1>Déboguer le desktop</h1>
            <h4>Console et panneaux avancés</h4>

            <p>(et aussi : <a href="http://discover-devtools.codeschool.com/">Discover DevTools</a> et <a href="http://www.youtube.com/playlist?list=PLNYkxOF6rcIBQ8j3J_PyM8JLAGKqZRByw">The Breakpoint</a>)</p>

            <aside class="notes" data-markdown>
              configuration de la console

              chrome://flag :

              * Activer les expérimentations dans les outils de développement
              * relancer chrome

              Cmd Alt J => ouvrir la console JS

              Cocher dans les outils de dev :

              * disable cache
              * enable JS source maps
              * enable CSS source maps
              * log XHR
              * show shadow DOM

              Montrer :
              * shortcuts
              * framework blackboxing
              * workspace
              * console.log d'un truc privé dans le code => save as global

            </aside>
          </section>

          <section id="console">
            <h1>La console</h1>

            <p>Bien plus que <code>console.log</code> !</p>
            <p>Complétion, Cmd+K/Ctrl+L, Shift+Return…</p>
            <p><a href="http://www.youtube.com/watch?v=4mf_yNLlgic&noredirect=1">Console Power User</a> !</p>
            <p>time / timeEnd</p>
            <p>dir, table</p>
            <p>$_, <em>Save As Global Variable</em>, copy</p>
            <p>$0 / inspect(el), Force Element State, $$</p>
            <p>monitorEvents, Break On… (+ Elements > Event Listeners)</p>

            <aside class="notes" data-markdown>
              .log : objets complexes, multi argument, .debug, .info, .warn, .error (stack trace)

* console.groupCollapsed('module 1')
* console.log('init');
* console.log('XHR');
* console.group('sous-module');
* console.log('autre');
* console.groupEnd();
* console.groupEnd();


* console.table( [
* ['name', 'age'],
* ['chris', 37],
* ['JP', 36]
* ]);

              * changement de contexte de frame
              * $- : faire un new Date(), puis $-
              * force element state : lien "console power user"
              * édition de CSS, colorpicker
              * monitorEvents( $0 ). $0 à $6
              * $$('p')
              * keys( document ) + copy( keys(document) )
            </aside>
          </section>

          <section id="panel-scripts">
            <h1>Le panneau Sources</h1>

            <p>Le pas à pas, en détail</p>
            <p>Des breakpoints sur <strong>tout</strong> !</p>
            <p>Expressions espions (watches)</p>
            <p>Pile d'appels (call stack).  Noms de fonctions.</p>
            <p>Portée</p>
            <p>Gestion des exceptions</p>
            <p><i>Beautifying</i> !</p>

            <aside class="notes" data-markdown>
              Démo sur la fonction de filtrage d'API de [l'API Prototype](http://api.prototypejs.org).

              * chercher une fonction filter (Ctrl+Shift+F)
              * breakpoint, pas à pas IN / OUT / OVER
              * breakpoint conditionnel (value.length > 4)
              * DOM breakpoint sur ul#search_results => on retrouve notre fonction filter
              * montrer closures (y compris quand elles ne sont pas là faute d'utilisation de la portée englobante)

              Sur Twitter :

              * démo break on XHR (sur action reply par ex.)
              * beautifying - pretty print
              * break on DOM events

              scp closure-debugger-hoisting-exception.html di:public/debug.html

              Sur [closure-debugger-hoisting-exception.html](http://delicious-insights.com/js-total/debug.html) :

              * mot clé debugger;
              * break on error
            </aside>
          </section>

          <section id="panel-resources">
            <h1>Le panneau Resources</h1>

            <p>Tout ce qui est stocké en local :</p>

            <ul>
              <li>Naviguer dans les sources ; iframes ; workers !</li>
              <li>Ressources chargées (catégorisées)</li>
              <li>Cookies</li>
              <li>Stockage session et local</li>
              <li>Bases de données</li>
              <li>AppCache</li>
            </ul>

            <aside class="notes" data-markdown>
              C'est le meilleur moyen de triturer ses cookies.  Indiquer qu'on utilisera les stockages local et session, ainsi qu'AppCache, le lendemain.

              appui long sur reload pour vider le cache (window only ?)
            </aside>
          </section>

          <section id="panel-network">
            <h1>Le panneau Network</h1>

            <p>Analyse des performances de chargement</p>
            <p>Distinction latence / chargement</p>
            <p>Visualisation détaillée (en-têtes, corps, preview…)</p>
            <p>Mode persistent (record)</p>
            <p>Toute l'activité : ressources, XHR, WebSockets…</p>

            <aside class="notes" data-markdown>
              PPC + network XHR + JSON + console.table

              Bien montrer les recoins des requêtes, le détail du timing, les previews, la copie cURL, parler des trucs HAR, et le Replay XHR (qui ne reprend pas les handlers, ceci dit ; juste pratique pour vérifier qu'on a débogué la couche serveur quand elle chiait à tort).

              clear cache, clear cookie, replay XHR

              démo HAR : save as HAR with content => harviewer (software is hard)
            </aside>
          </section>

          <section id="panel-timeline">
            <h1>Le panneau Timeline</h1>

            <p>Analyse des performances d'exécution</p>
            <p>Chargement / Parsing / Rendering / Painting</p>
            <p>Groupes asynchrones</p>
            <p>Monitoring événements, FPS, RAM ; GC !</p>
            <p>Mode persistent, là aussi.</p>
            <p>Réduction du bruit (&lt; 15ms)</p>

            <aside class="notes" data-markdown>
              Très dur à bien mettre en situation, comme Profiles.  Insister à mort sur [Discover DevTools](http://discover-devtools.codeschool.com/) pour bien les prendre en main.

              timeline event / frame / memory avec reveal.js


            </aside>
          </section>

          <section id="panel-profiles">
            <h1>Le panneau Profiles et Rendering</h1>

            <p>Préalable <strong>obligatoire</strong> à l'optimisation !</p>
            <p>Pas seulement JS : sélecteurs CSS et occupation RAM</p>
            <p>Profils/snapshots nommés + persistence possible</p>

            <aside class="notes" data-markdown>
              Très dur à bien mettre en situation, comme Timeline.  Insister à mort sur [Discover DevTools](http://discover-devtools.codeschool.com/) pour bien les prendre en main.

              rendering : Esc, avec FPS meter et paint rectangles
            </aside>
          </section>

          <section id="panel-audits">
            <h1>Le panneau Audits</h1>

            <p>Genre DOM Monster + GTMetrix…</p>
            <p>Performances <em>loadtime</em> + <em>runtime</em></p>
            <p>État actuel ou dès chargement</p>
            <p>Voir aussi <a href="http://javascriptrocks.com/performance/">JS Performance Rocks!</a></p>

            <aside class="notes" data-markdown>
              Montrer vite fait mais préférer PageSpeed Insights (français, plus exhaustif, file les ressources déjà optimisées). JP, tu as peut-être des conseils d'exploit/démo/liaisons ici, sans déborder en temps ?
            </aside>

          </section>

          <section id="panel-emulation">
            <h1>Le tiroir Émulation</h1>

            <p>Émuler le touch, la géoloc, l'accéléromètre</p>
            <p>CSS print</p>
            <p>RWD, taille d'écran et densité de pixels</p>
            <p>Network Throttling (y compris offline)</p>
            <p>User Agent</p>

            <aside class="notes" data-markdown>
              raccourci Esc de n'importe où
            </aside>

          </section>

        </section>


        <section id="what-can-we-use">
          <section class="chapter">
            <h1>À quoi a-t-on droit ?</h1>
            <h4>Et comment compenser ?</h4>
          </section>

          <section id="refs">
            <h1>Références</h1>

            <p>
              <a href="http://caniuse.com/">CanIUse</a>
              <span class="fragment">+ <a href="http://caniuse.com/#stats_import">Google Analytics</a> = <strong>Awesome</strong> !</span>
            </p>
            <p class="fragment"><a href="http://html5please.com/">HTML5 Please</a> : détails de prise en charge et polyfills</p>
            <p class="fragment"><a href="http://html5test.com/">HTML5Test</a>&nbsp;: et ton navigateur, il roxxe&nbsp;?</p>

            <aside class="notes" data-markdown>
              Faire une démo avec un de vos sites sur GA.  Penser à purger votre LocalStorage CIU avant, pour ne pas être d'entrée de jeu en mode Custom.  Attention, la beta en cours peut déconner sur le custom…
            </aside>
          </section>

          <section id="modernizr">
            <h1>Modernizr</h1>

            <p>In-page feature detection</p>
            <p>Sans doute le seul script forcément à chargement synchrone, et dans le head :-)</p>
            <p>À peu près tous les aspects de CSS2/3 et « HTML5 »</p>
            <p>Classes positives/négatives sur le document : évite au passage de saloper nos feuilles à coups de hacks CSS</p>
            <p><a href="http://modernizr.com/">modernizr.com</a></p>

            <aside class="notes" data-markdown>
              « Le seul script qui devrait être chargé en synchrone depuis le `&lt;head&gt;` »

              * démo du packaging custom
              * on peut montrer que ça s'exécute super rapidement (console.time())
            </aside>
          </section>

          <section id="polyfills">
            <h1>Polyfills</h1>

            <p>Un polyfill est un ersatz, un substitut qui tente de fournir une API identique (ou au moins équivalente) à celle d'une fonction non prise en charge par l'environnement (typiquement le navigateur)</p>
            <p>Y'en a <a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills">plein</a>&nbsp;!</p>
            <p>Les fameux <a href="http://code.google.com/p/ie7-js/">IEx.js</a> de Dean Edwards, <a href="http://raphaeljs.com/">Raphaël</a>, <a href="https://github.com/afarkas/html5shiv">html5shiv</a>, <a href="http://code.google.com/p/explorercanvas/">ExCanvas</a>, <a href="http://sublimevideo.net/">SublimeVideo</a>, <a href="http://socket.io/">Socket.IO</a>, <a href="https://github.com/kriskowal/es5-shim/">es5-shim</a>…</p>
            <aside class="notes" data-markdown>
              Faire le distingo entre *shim* (API identique au natif, même si partielle, ex. ES5-Shim ou ExCanvas) et *polyfill* (API spécifique car l'identique est infaisable, ex. SVG).
            </aside>
          </section>
        </section>

        <section id="codebase">
          <section class="chapter">
            <h1>Organiser la codebase</h1>
          </section>

          <section id="modules">
            <h1>Modules</h1>

            <p><a href="http://requirejs.org/docs/why.html">Pourquoi des modules ?</a></p>
            <p><a href="http://www.commonjs.org/specs/modules/1.0/">CommonJS</a></p>
            <p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a></p>
            <p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:modules">Harmony</a></p>

            <aside class="notes" data-markdown>
              Introduire la notion avant de parler des formats :

              * grosse codebase, diviser pour mieux régner
              * réutilisation de code
              * gestion des dépendances complexes
              * pas de pollution globale
            </aside>
          </section>

          <section id="commonjs">
            <h1>CommonJS</h1>

            <p>Le format historique, synchrone, popularisé par Node</p>
            <p>On parle en fait de CommonJS/1.0 (plein d'extensions…)</p>
            <p>Très facile à comprendre :</p>

            <br/>
            <p class="fragment"><code>exports.<i>key</i> = <i>value</i></code></p>
            <p class="fragment"><code><i>mod</i> = require('<i>pathspec</i>')</code></p>

            <aside class="notes" data-markdown>
              * la base de Node.js, Brunch et Browserify (chargeur de fichier concaténés)
              * on en fera dans la SPA de demain
              * Un fichier = un module
              * construit l'arbre des dépendances
              * Enrobage automatique donc obligatoire
              * toute variable doit être locale
              * renvoi de l'API publique avec exports.key ou module.exports
              * de l'autre côté : var machin = require('chemin') sans le .js
            </aside>
          </section>

          <section id="commonjs-2">
            <h1>CommonJS</h1>
            <p><img src="assets/commonjs.png"></p>
          </section>

          <section id="amd">
            <h1>AMD</h1>

            <p>Mais <a href="http://requirejs.org/docs/whyamd.html">pourquoi&nbsp;?</a></p>
            <p>Asynchronous Module Definition</p>
            <p>Conçu notamment pour les browsers</p>
            <p>Tout module CommonJS peut être « enrobé » en AMD</p>
            <p>Principal loader : <a href="http://requirejs.org/">RequireJS</a></p>
            <p>Clé de voute :</p>
            <br/>
            <p><code>define('<i>name</i>', [<i>path, …</i>], <i>cb</i>(<i>mod, …</i>) {})</code></p>

            <aside class="notes" data-markdown>
              * machin = require(truc) pas possible à cause de l'async, d'où callback
              * Enrobage manuel donc pas obligatoire…
              * grosse mode il y a qlqs années. est resté requireJS (et LabJS, yepnope.js …)

            </aside>
          </section>

          <section id="amd-2">
            <h1>AMD</h1>
            <p><img src="assets/amd.png"></p>
            <aside class="notes" data-markdown>
             * explicite avec define + return de l'API publique
             * nom du module peut être différent du nom du fichier (mais à configurer)
             * dépendances listées + référence locale
             * tri topologique et décision de téléchargement
            </aside>

          </section>

          <section id="harmony-modules">
            <h1>Modules Harmony</h1>

            <p><a href="http://jsmodules.io/">ES6 fournit une syntaxe native de modules</a>.</p>
            <p>Syntaxe souple, inspirée entre autres de Python.  Déjà disponible dans certaines implémentations préalables (Node 0.11, Chrome 35+, Firefox 25+…).</p>

            <p><a href="http://jsmodules.io/cjs.html">Comparez avec CommonJS</a> (mapping facile)</p>
            <p><a href="https://github.com/systemjs/systemjs">SystemJS</a> est un chargeur universel qui permet, dès maintenant, de faire collaborer les 3 types de modules et les scripts globaux, en cas de besoin.  Pour ES6, il repose sur l'excellent shim <a href="https://github.com/ModuleLoader/es6-module-loader">es6-module-loader</a>.</p>

            <aside class="notes" data-markdown>
              * prévu pour 2013, puis début 2014, mi-2014
              * marche dans Fx et options avancées de Chrome
              * même concepts que CommonJS mais pas compatible.
              * mais traducteurs et transpiler existent
              * concepts : modules synchrone, pré-compilation, résolution de l'arbre au parsing ou à l'exécution

              * 3 nouveaux mot clés : module, export, import
              * montrer la syntaxe sur le site
              * exemple jQuery : import $ from jquery
            </aside>
          </section>
        </section>

        <section id="frameworks">
          <section class="chapter">
            <h1>Frameworks</h1>
          </section>

          <section id="why-frameworks">
            <h1>Dis papa pourquoi ?</h1>

            <p><strong>Parce que !</strong></p>
            <p>Dès qu'on commence à avoir une masse de code, un formalisme et un socle bien testé et bien maintenu deviennent indispensables.  C'est comme pour le côté serveur !</p>

            <p>On perçoit quelques grandes catégories :</p>

            <p>La base : le squelette de MVC, sans plus</p>
            <p>Les <i>full clients</i> : la totale… pour le côté client</p>

            <aside class="notes" data-markdown>
              * Pour arretter de réinventer la roue
              * base MVC : pas de structure ou de syntaxe imposée
              * full clients : prends des décisions sur la vue, le templating, le routage, la communication serveur
              * full stack : généralement Node, comme Meteor. Dur à aborder
            </aside>
          </section>

          <section id="frameworks-basic">
            <h1>La base</h1>
            <h2><a href="http://backbonejs.org/">Backbone</a></h2>

            <p>Comme son nom l’indique, juste l’ossature critique</p>
            <p><strong>De loin le plus répandu</strong> (même sans marketing)</p>
            <p>Une couche modèle bien solide, à la base REST+JSON</p>
            <p>Couche routeur pas mal</p>
            <p>Couche vue minimaliste mais <strong>riche en BP</strong></p>
            <p>Énormément de <a href="http://backplug.io/">plugins</a> pour enrichir le tout</p>
            <p>(notamment <a href="http://marionettejs.com/">Marionette</a> pour ajouter du lourd côté vues)</p>

            <aside class="notes" data-markdown>
              * le plus connu (300 fois plus de sites que angular ou ember)
              * pérenne, open source, solide, syntaxe compréhensible
              * Model : solide, facilite communication serveur
              * routage : OK, gère pushState de HTML5
              * événements, facilite les bonnes pratiques jQuery
              * View (qui est plus un Controler en fait), on y rajoute parfois du Marionette ou du thorax (Handlebars)
            </aside>

          </section>

          <section id="frameworks-full-client">
            <h1>Full Client</h1>

            <p><a href="http://emberjs.com/">Ember.js</a></p>
            <p><a href="http://angularjs.org/">Angular.js</a></p>
            <p>Backbone + <a href="http://marionettejs.com/">Marionette</a></p>
            <p><a href="https://github.com/chaplinjs/chaplin">Chaplin</a></p>
            <p><a href="http://walmartlabs.github.com/thorax/">Thorax</a></p>
            <p>…</p>
          </section>

          <section id="frameworks-angular">
            <h1>Full Client</h1>
            <h2><a href="http://angularjs.org/">Angular.js</a></h2>

            <p>Déjà ancien mais Google bombarde en marketing depuis 2010</p>
            <p>Sur-architecturé ; ratio puissance/complexité plutôt bas</p>
            <p>Soucis récurrents sur les choix de data sources, les scopes…</p>
            <p>Les directives et le dirty checking sont très lourds en perfs</p>
            <p>Angular 2, sera nettement mieux mais 10% compatible 1.</p>
            <p><strong>Beaucoup de bons concepts mais l'exécution est faiblarde.</strong></p>

            <aside class="notes" data-markdown>
              Angular :

              * pas du vrai open source : pull request ignorées
              * Google aime t il JS ? => dart, GWT
              * retour de stagiaires formation Node : marre d'angular, on passe à Ember
              * 4 types de datasource !
              * scope compliqué à comprendre
              * directives = webcomponents, top pour la testabilité
              * bon écosystème (builder, runner)
              * sur-architecturé => http://codeofrob.com/entries/you-have-ruined-javascript.html
              * tu te sens d'attendre IE 13 ?
              * tient pas le nombre d'infos à afficher à l'écran
              * on aime ou pas les directives dans le DOM
              * Polémique Angular 2 : ré-écriture complète
            </aside>
          </section>

          <section id="frameworks-ember">
            <h1>Full Client</h1>
            <h2><a href="http://emberjs.com/">Ember.js</a></h2>

            <p>Issu de SproutCore ; influencé par Rails</p>
            <p>Yehuda Katz &amp; Tilde (jQuery, Rails, Handlebars…)</p>
            <p>Bon ratio puissance/complexité</p>
            <p>Porte de sortie fréquente des « brûlés par Angular »</p>
            <p>Désormais 100% ES6 (transpilé), dont modules</p>
            <p>Data binding plus léger et performant, via HTMLBars</p>

            <aside class="notes" data-markdown>
              Ember :

              * récent, mais vient de sproutcore, pour l'appli iCloud
              * influence Rails
            </aside>
          </section>

          <section id="frameworks-over-backbone">
            <h1>Full Client</h1>
            <h2>Solutions basées Backbone</h2>

            <h3><a href="https://github.com/chaplinjs/chaplin">Chaplin</a></h3>
            <p>Équivalent à Backbone + Marionette + du sucre syntaxique et des conventions de structuration et de nommage ; très sympa.</p>

            <h3><a href="http://walmartlabs.github.com/thorax/">Thorax</a></h3>
            <p>Le plus « battle-tested » au monde : au cœur de Walmart Mobile.  Énormément de services, factories, conventions, etc.  Archi industrielle adaptée aux (très) grosses applis clients.</p>
          </section>
          <aside class="notes" data-markdown>
              * thorax : au niveau de angular si on veut de la grosse architecture
            </aside>
        </section>

        <section>
          <section id="brunch" class="chapter">
            <h1><a href="http://brunch.io/">Brunch.io</a></h1>

            <p>Tout le monde parle de Grunt, Gulp, Broccoli…  Mais Brunch est là depuis 4 ans et les enterre tous en <strong>application assembly</strong>.</p>

            <p>Pas un exécuteur générique de tâches</p>
            <p>Une vraie pipeline optimisée pour le <a href="http://brunch.io/compare.html">build d'applis</a></p>
            <p>Extrêmement <strong>réactif</strong> : entre 60ms et 200ms de la sauvegarde de fichier à la fin des rebuilds appropriés.</p>
            <p>Énormément de puissance en très (très) peu de config ; repose plutôt sur plein de conventions (mais reste configurable)</p>
            <p>Écosystème très riche de <a href="http://brunch.io/plugins.html">plugins</a></p>

            <aside class="notes" data-markdown>
              grunt
              * travaille au niveau du fichier

              Gulp
              * marche en flux

              Bizarrement, nous on préfère Brunch.  En gros, défonce Yeoman et ses énormes scripts Grunt en perf.  Mais Yeoman fait plein de trucs en plus, Brunch est un **assembleur d'appli** ; en revanche, à ce jeu-là, il enterre tout le monde (Grunt, Gulp, etc.).

              Brunch
              * en concurrence avec les nouveaux : gulp, brocoli
              * depuis 4 ans
              * un vrai builder d'application
              * en mode pipeline

              plugins
              * templating
              * tous les transpilers
              * les minifiers, spriter, optimisation d'images
              * linters, documentation, autoreload
              * appcache, cache client en refaisant les URLs …


              Ça tombe bien, c'est là qu'on DL `spa-basis.zip`, qu'on la décompresse, `npm install` et `npm start`.  Du coup quand ça marche, on peut faire du Cmd+S et montrer le temps de réaction de Brunch :-)

              Pour les Windowsiens : activer l'option `usePolling` s'ils loupent des modifs / nouveaux fichiers (ça sera plus lent à réagir mais au moins ça réagira).
            </aside>
          </section>

          <section id="brunch-config">
            <h1>Config basique</h1>

            <p>Fichier <code>brunch-config.coffee</code> (ou <code>.js</code>)</p>

            <pre><code class="coffeescript">exports.config =
  files:
    javascripts:
      joinTo: 'app.js'
    stylesheets:
      joinTo: 'app.css'
    templates:
      joinTo: 'app.js'</code></pre>

            <p>JS = sources ES3/5/6, TypeScript, CoffeeScript, etc.</p>
            <p>Styles = sources CSS, SASS, LESS, Stylus, etc.</p>
            <p>Templates = sources Handlebars, Jade, etc.</p>
          </section>

          <section id="brunch-output">
            <h1>Ce que ça fait</h1>

            <ol>
              <li>Transpiling (ES6, CoffeeScript, TypeScript…)</li>
              <li>Préprocesseurs (LESS, SASS, Stylus…)</li>
              <li>Précompilation de templates vers JS (Handlebars, Jade…)</li>
              <li>Enrobage en modules (par défaut CommonJS)</li>
              <li>Concaténation intelligente</li>
              <li>Source Maps v3</li>
              <li>Minification optimale (JS, CSS) si en prod</li>
            </ol>

            <p>Si le plugin est présent, ses traitements sont automatiques !</p>

            <p>Mais aussi : spriting et optimisation des images, maintenance manifeste AppCache, injection live CSS, reloading si changement JS, etc.</p>
          </section>

          <section id="brunch-conventions">
            <h1>Conventions Brunch</h1>

            <p>Tout ça est configurable finement, mais par défaut :</p>

            <ul>
              <li>Les dossiers exploités sont <code>app/</code> et <code>vendor/</code></li>
              <li>Le dossier cible est <code>public/</code></li>
              <li>Les fichiers dont le nom démarre par <code>_</code> sont ignorés (on suppose qu'ils seront importés/inclus par d'autres)</li>
              <li>Le contenu des dossiers <code>assets/</code> est copié verbatim</li>
              <li>Les scripts dans les dossiers <code>vendor/</code> ne sont pas enrobés en modules, simplement concaténés</li>
              <li>Les autres scripts sont enrobés en modules CommonJS avec un nom dérivé de leur chemin sous <code>app/</code></li>
            </ul>
          </section>

          <section id="brunch-plugins">
            <h1>Plugins Brunch</h1>

            <p>Ce sont des modules Node qu'il suffit d'installer en local pour qu'ils soient pris en compte.</p>
            <p>Ils s'inscrivent sur un type de fichier (<code>javascript</code>, <code>stylesheets</code> ou <code>templates</code>) et 1+ extension/motif de fichier.</p>
            <p>Par exemple, <code>jade-brunch</code> s'inscrit sur le type <code>templates</code> pour l'extension <code>.jade</code>.</p>
            <p>Par défaut, Brunch ne traite aucun type de fichier d'office ; il lui faudrait au moins <code>javascript-brunch</code> pour s'occuper des <code>.js</code> et <code>css-brunch</code> pour s'occuper des <code>.css</code>.  Donc très léger !</p>

            <p>Y'en a <a href="http://brunch.io/plugins.html">des tonnes</a> :-)</p>
          </section>

          <section id="brunch-watch">
            <h1>Watcher Brunch</h1>

            <p>La commande <code>brunch build</code> fait un build one-shot, mais…</p>
            <p><code>brunch watch</code> poursuit en surveillant les dossiers définis pour mettre à jour, <strong>super vite</strong>, les fichiers cibles nécessaires.</p>
            <p>Elle peut même fournir un mini-serveur HTTP sur le dossier cible, avec <code>brunch watch --server</code></p>
          </section>

          <section id="brunch-prod">
            <h1>Brunch pour la prod</h1>

            <p>Par défaut, les fichiers produits sont orientés développement : HTML indenté, JS et CSS non minifiés, etc.</p>
            <p>Pour une release, on demande à Brunch de produire les versions de production avec <code>brunch build --production</code></p>
            <p>Si les plugins idoines sont présents (ex. <code>uglify-js-brunch</code> et <code>clean-css-brunch</code>), une minification optimale est effectuée.  On peut aussi optimiser les images, etc.</p>
          </section>
        </section>

        <section>
          <section id="spa-intro" class="chapter">
            <h1>Notre p’tite SPA</h1>
          </section>

          <section id="what-does-it-do">
            <h1>Que fait-elle ?</h1>

            <p>Sorte de µ-Foursquare</p>
            <p>Regarde où on est, cherche des endroits où manger, check-in !</p>
            <p>Historise les check-ins</p>
            <p>Gestion pratique du offline</p>

            <aside class="notes" data-markdown>
              on peut faire une démo en local de spa-final
            </aside>
          </section>

          <section id="spa-brunch-config">
            <h1>Config Brunch (1/2)</h1>

            <pre><code class="coffeescript">files:
  javascripts:
    joinTo: 'app.js'
  stylesheets:
    joinTo: 'app.css'
  templates:
    joinTo: 'app.js'

modules:
  nameCleaner: (path) ->
    path
      # Strip app/ and app/externals/ prefixes
      .replace /^app\/(?:externals\/)?/, ''
      # Allow -x.y[.z…] version suffixes in mantisses
      .replace /-\d+(?:\.\d+)+/, ''
      # Allow -fr lang suffixes in mantisses
      .replace '-fr.', '.'
</code></pre>

            <aside class="notes" data-markdown>
              nameCleaner : exemple require('moment') ira chercher app/externals/moment-2.2.1-fr.js
            </aside>
          </section>

          <section id="spa-brunch-config-2">
            <h1>Config Brunch (2/2)</h1>

            <pre><code class="coffeescript">plugins:
  appcache:
    externalCacheEntries: [
      'http://maps.gstatic.com/mapfiles/place_api/icons/bar-71.png'
      'http://maps.gstatic.com/mapfiles/place_api/icons/generic_business-71.png'
      'http://maps.gstatic.com/mapfiles/place_api/icons/restaurant-71.png'
      'http://maps.gstatic.com/mapfiles/place_api/icons/wine-71.png'
    ]
    network: ['*', 'http://*', 'https://*']

server:
  path: 'jst-server.coffee'

watcher:
  usePolling: true
</code></pre>

            <aside class="notes" data-markdown>

            </aside>
          </section>

          <section id="stack">
            <h1>La stack</h1>

            <p class="fragment"><a href="http://learnboost.github.io/stylus/">Stylus</a> et <a href="http://lesscss.org/">LESS</a> (<a href="http://getbootstrap.com/">Bootstrap</a>) pour les CSS</p>
            <p class="fragment"><a href="http://jade-lang.com/">Jade</a> pour le templating</p>
            <p class="fragment"><a href="http://backbonejs.org/">Backbone</a> pour le MVC côté client</p>
            <p class="fragment">W3C / HTML5 pour la <a href="https://developer.mozilla.org/fr/docs/Using_geolocation">géolocalisation</a> et la <a href="https://developer.mozilla.org/fr/docs/%C3%89v%C3%A8nements_online_et_offline">détection offline</a></p>
            <p class="fragment"><a href="https://developer.mozilla.org/fr/docs/DOM/Storage">sessionStorage</a> pour du stockage local transient</p>
            <p class="fragment"><a href="http://brian.io/lawnchair/">Lawnchair</a> pour l'abstraction de stockage local persistant</p>
            <p class="fragment"><a href="https://developers.google.com/maps/">Google Maps</a> pour l'obtention de POI où manger</p>
            <p class="fragment"><a href="https://developer.mozilla.org/fr/docs/Utiliser_Application_Cache">ApplicationCache</a> pour le cache offline</p>
            <p class="fragment"><a href="http://momentjs.com/">Moment.js</a> pour l'horloge et <a href="http://underscorejs.org/">Underscore.js</a> pour l'algo</p>
            <p class="fragment"><a href="http://nodejs.org/">Node</a> et <a href="http://coffeescript.org/">CoffeeScript</a> pour le serveur de démo</p>

            <aside class="notes" data-markdown>
              * Stylus : montrer le style sur l'élément body (sourcemap), less : montrer ce qui vient de bootstratp
              * Jade : montrer #checkInUI qui se trouve dans home.jade
              * * définition du block main
              * * inclusion de _layout.jade
              * * montrer au passage les FIXME dans #onlineMarker et #ticker
              * Backbone : dans initialize.js , juste montrer le require
              * geoloc : montrer sur spa-final
              * offline : plus tard
              * sessionStorage : sur spa-final, panneau ressources
              * lawnchair : site + montrer que externals/lawnchair-dom.js existe
              * Gmaps / offline : plus tard
              * Moment.js : montrer site
              * node et coffee : Montrer jst-server.coffee
              * * npm start => package.json => brunch watch => brunch-config => node jst-server.coffee
              * * get / : public/index.html => montre le body vide
            </aside>

          </section>

          <section id="spa-boot">
            <h1>« Boot »</h1>

            <p>Bon, pour le moment, je passe sous Keynote…</p>
            <aside class="notes" data-markdown>
              * montrer slides-material/spa-boot.pdf
              * initialize.js - require('moment') => expliquer que le chemin a été retravaillé par brunch-config - nameCleaner
              * à retenir
              * * on renseignera systématiquement template, afterRender et getRenderData
            </aside>
          </section>

          <section id="spa-steps">
            <h1>Pour aujourd'hui…</h1>

            <ol>
              <li>Faire tourner</li>
              <li>Récupérer et retenir le nom</li>
              <li>L’horloge</li>
              <li>Vues imbriquées</li>
              <li>Géolocalisation et Google Maps Places</li>
              <li>Modèle Backbone d’état UX</li>
              <li>La persistence, les collections Backbone et la synchro</li>
            </ol>
          </section>

          <section id="spa-runit">
            <h1>Faire tourner</h1>
            <h3>le socle</h3>

            <pre><code data-trim data-noescape class="bash">
$ cd spa-basis
$ <u>npm install</u>
…
$ <u>npm start</u>

> js-total-spa@2.0.0 start …/spa-basis
> <u>brunch watch --server</u>

22 Oct 16:59:34 - info: starting custom server
Cannot load db.json
<b class="right">Listening on port 3333… WebSockets enabled.</b>
22 Oct 16:59:34 - info: custom server started, initializing watcher
22 Oct 16:59:35 - info: compiled 37 files and 1 cached into 2 files, copied…
            </code></pre>
            <aside class="notes" data-markdown>
              problèmes ?

              * tester avec brunch w
              * fenêtre > 950px pour voir la 2nde colonne
            </aside>
          </section>

          <section id="spa-username">
            <h1>Retenir le nom</h1>

            <p>Bon vieux <code>prompt</code> + persistance dans <code><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage#sessionStorage">sessionStorage</a></code></p>
            <p>Saisies pourries (<code>null</code>, whitespaces…), non persistées : nom l’aléatoire.  Première rencontre avec <a href="http://underscorejs.org">Underscore</a> :-)</p>
            <pre><code data-trim data-noescape class="javascript" data-file="lib/notifications.js">
var userName = <u>sessionStorage.</u>userName ||
  $.trim(<u>prompt</u>("Votre nom d’utilisateur"));
            </code></pre>

            <p>1er <code>getRenderData()</code> et variable dans un template Jade.</p>

            <pre><code data-trim data-noescape class="javascript" data-file="views/home_view.js">
getRenderData: function getHomeRenderData() {
  return { userName: userName };
}
            </code></pre>

            <pre><code data-trim data-noescape class="javascript" data-file="views/templates/_layout.jade">
              span<u>= userName</u>
            </code></pre>

            <aside class="notes" data-markdown>
              * démo de sessionStorage : sessionStorage
              * création app/lib/notificationS.js
              * var userName, prompt, exports => reload : toujours rien
              * édition home_view : require(notifications).userName, création getRenderData, return userName => prompt apparaît
              * édition _layout.jade : premier FIXME par span= userName. Faire un touch sur home.jade pour aider brunch à reload
              * retour notifications.js :
              * * save dans sessionStorage
              * * random si userName null => require underscore
              * * $ trim sur le prompt => require jquery
              * fermer notifications.js

            </aside>

          </section>

          <section id="backbone-views">
            <h1>Backbone.View</h1>
            <h3>Rien que l’essentiel (mais bien choisi)</h3>

            <p><code><a href="http://backbonejs.org/#View">Backbone.View</a></code> ne fournit/impose que peu de chose, mais top</p>
            <p>Conteneur DOM : <code>el</code>, <code>$el</code></p>
            <p>Gen du conteneur : <code>tagName</code>, <code>id</code>, <code>className</code>, <code>attributes</code></p>
            <p>Modèle associé : <code>model</code> / <code>collection</code></p>
            <p>Lookup jQuery <span lang="en">prescoped</span> : <code>$</code> (on fait <code>this.$(…)</code>)</p>
            <p>Rendering : <code>render()</code></p>
            <p>Délégation d’événements : <code>events</code></p>

            <aside class="notes" data-markdown>
              * View Backbone ressemble plus à un controler : ne suppose rien, plutôt bcp de conventions
              * on peut rendre global application.homeView pour l'inspecter (ex, dans router.js)
              * application.homeView.$el.jquery => la version jQuery
              * présenter views/view.js

            </aside>
          </section>

          <section id="spa-clock">
            <h1>L’horloge</h1>

            <p>Injection initiale + mise à jour ultérieure.</p>
            <p>Le DOM doit être garanti à jour : <code>afterRender</code>.</p>
            <p>Bon vieux <code>setInterval(…, 1000)</code></p>
            <pre><code data-trim data-noescape class="javascript" data-file="views/home_view.js">
<u>afterRender</u>: function afterHomeRender() {
  this.startClock();
},

// …

startClock: function startClock() {
  this._clock = this._clock || <u>this.$</u>('#ticker');
  <u>var that = this;</u>
  setInterval(function() {
    <u>that</u>._clock.text(<u>that</u>.getRenderData().now);
  }, 1000);
}
            </code></pre>

            <aside class="notes" data-markdown>
              * édition views/home_view.js : getRenderData, renvoi now : Date.now
              * injection initiale de l'heure : layout.jade : span#ticker= now (toucher home.jade pour prise en compte par brunch)
              * timestamp apparaît ? présentation moment.js + require + format('dddd D MMMM YYYY HH:mm:ss')

              * Mise à jour : exécuter en console application.homeView.render()
              * création de afterRender() => this.startClock()
              * création de startClock() => MAJ + setInterval
              * ça marche, fermeture de home.jade et layout.jade
            </aside>
          </section>

          <section id="spa-nested-views">
            <h1>Vues imbriquées</h1>

            <p>Le pavé de gauche contient une vue complexe avec des tas de gestions spécifiques : on va en faire un contrôleur (<code>Backbone.View</code>) dédié, et l'intégrer dans la vue racine.</p>
            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
var View = require('./view');

module.exports = View.extend({
  template: require('./templates/<u>check_in</u>')
});
            </code></pre>

            <pre><code data-trim data-noescape class="javascript" data-file="views/home_view.js">
var CheckInView = require('./check_in_view');

// …

  afterRender: function afterHomeRender() {
    this.startClock();
    <u>new CheckInView({ el: this.$('#checkInUI') }).render();</u>
  },
            </code></pre>

            <aside class="notes" data-markdown>
              * création views/check_in_view.js . Conseiller de copier / coller depuis home_view
              * on garde juste require(view), template: templates/check_in
              * modif home_view ( require + new  CheckInView().render
              * plomberie OK (affichage col gauche), on peut fermer home_view.js
            </aside>

          </section>

          <section id="spa-geoloc">
            <h1>Géolocalisation</h1>

            <p>On a 2 modules qui nous découplent des technos sous-jacente :</p>
            <p><code>lib/location</code> par-dessus la <a href="https://developer.mozilla.org/fr/docs/Using_geolocation">géoloc W3C</a></p>
            <p><code>lib/places</code> par-dessus <a href="https://developers.google.com/places/documentation/?hl=fr">Google Places</a></p>

            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
afterRender: function() {
  this.fetchPlaces();
},

fetchPlaces: function() {
  <u>locSvc.getCurrentLocation</u>(function(lat, lng) {
    console.log(lat, lng);
    if (_.isString(lat)) {
      return;
    }
    <u>poiSvc.lookupPlaces</u>(lat, lng, function(places) {
      console.log(places);
    });
  });
}
            </code></pre>

            <aside class="notes" data-markdown>
              * retour à check_in_view.js
              * création afterRender
              * création fetchPlaces avec console
              * console s'affiche ?

              Explication des services

              * explication HMTL5 geoloc, + démo : navigator.geolocation.getCurrentPosition(function() { console.log( arguments ); }); (permission à accorder à Chrome)
              * parler de lib/location
              * * export de getCurrentLocation
              * * $FAKE, offline, vieux navigateur : coordonnées en dur, pratique pour dev
              * * cache en localStorage
              * **require lib/location**, appel de getCurrentLocation, console
              * parler de lib/places
              * * gestion offline, filtres des restaus, stockage local, $FAKE
              * * complexité de l'API V3 (pas un vrai Web Service), API super lourde
              * * gestion des timeout, et re-essai automatique
              * * gestion du double appel (recherche + distance),puis tri
              * * au final lookupPlaces(lat, lng, callback)
              * **require lib/places**
              * dans callback de getCurrentLocation : lookupPlaces() => console.log(places)


              Affichage :

              * montrer check_in.jade, mettre != placeList (pour le HTML non escaped)
              * éditer check_in_view, getRenderData, return placeList:'searching…'
              * ajout de listTemplate:require places, puis exécution du template dans getRenderData, via View.renderTemplate
              * pourquoi le spinner tourne toujours ? > MAJ du DOM à faire. On pourrait faire comme pour l'heure (jQuery direct => pas descriptif OU that.render() => boucle infinie ), mais on va plutôt faire du data-binding
            </aside>
          </section>

          <section id="spa-ux-model">
            <h1>Modèle Backbone</h1>
            <h3>pour l’état de l’UX</h3>

            <p>Passer par du data-binding pour contrôler proprement l’état de l’UI et l’UX en fonction des éléments de l’état de la vue (latitude, longitude, POIs, sélection, commentaire…).</p>

            <p>Le plugin le plus abouti est actuellement <a href="http://nytimes.github.io/backbone.stickit/">Backbone.StickIt</a></p>
            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
<u>bindings</u>: {
  // sélecteur CSS -> descripteur de binding, +/- avancé
  '#comment': 'comment',
  '#places': {
    observe: ['places', 'placeId'],
    onGet: function() { return this.getRenderData().placeList; },
    updateMethod: 'html'
  },
  // …
}
            </code></pre>
            <aside class="notes" data-markdown>
              Explication modèle Backbone

              * regroupable en Collection avec toutes les méthodes de underscore (add, pick, pop, push, sort, findWhere, comparator …)
              * hérite de méthodes undersore : pick, omit
              * synchronisation automatique possible avec le serveur (plus tard) (sync, fetch, save)
              * events (change, )
              * get / set / toJSON


              * explication de ce que l'on veut représenter : stocker lat/lng, resto sélectionné, dernière liste des restos, commentaire
              * Création models/check_in_ux.js
              * * recopie de models/check_in.js
              * * ajout des defaults pour lat, lng, placeId, places, comment
              * modif check_in_view
              * * création méthode initialize, avec appel du parent et définition du modèle + console.log(this.model.toJSON());
              * * dans getCurrentLocation : model.set lat lng
              * * dans lookupPlaces : model.set places
              * * dans getRenderData : this.model.get('places')
              * * tester avec un that.render() pour montrer la MAJ (boucle infinie)

              Explication data-binding (moins de manip DOM, pas de markup dans le HTML), des librairies dédiées (knockoutJS, Angular…), puis stickit

              * montrer que stickit vient de app/initialize.js : require('backbone-stickit')
              * démo avec commentaire mis en dur dans les défauts "bindings"
              * version plus compliquée (2 variables à observer, formatage) avec #geoloc. Montrer la doc : http://nytimes.github.io/backbone.stickit/#bindings/observe
              * places, avec getRenderData().placeList + updateMethod à html (text par défaut)
              * expliquer le template places.jade au passage (each, unless, if ternaire, helper secondsToMinutes défini dans lib/view_helper)
              * affichage lat / lng et liste des restaus OK

            </aside>
          </section>


          <section id="spa-backbone-events">
            <h1>Events Backbone</h1>

            <p>Système de convention pour écouter les actions sur l'UX et y lier des méthodes de la View.</p>

            <p>Très efficace : gère la délégation d'événements, le verrouillage du contexte d'exécution (<code>this</code>) et se limite aux enfants de <code>this.$el</code></p>
            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
<u>events</u>: {
  // La clé est composée du nom de l'événement et du sélecteur CSS.
  // La valeur est le nom de la méthode du controler
  'click header button': 'fetchPlaces',
  'click #places li': 'selectPlace',
  'submit': 'checkIn'
}
            </code></pre>
            <aside class="notes" data-markdown>
              * explication events View Backbone. Équivalent à $(this.el).on('click', 'header button', \\_.bind( this.fetchPlaces, this) ))

              Bouton rechercher qui relance la recherche

              * ajout events, avec seulement 'click header button':'fetchPlaces'
              * dans fetchPlaces : model set defaults


              sélection du POI

              * but : mettre une classe active, extraire le placeId
              * events : click #places li': 'selectPlace',
              * création selectPlace. Démo du this, e.target et e.currentTarget
              * mise à jour du model : placeId
              * montrer places.jade : le if sur la classe active. Demander comment on remet à jour ?
              * dans bindings, #places, observe : rajout de placeId
              * dans getRenderData, rajout de placeId. utiliser model.pick(places, placeId)
              * sélection OK, un clic sur le bouton doit aussi marcher (re-fetch et reset)


              détails du submit : ON à la sélection, OFF au submit et pendant la recherche

              * bindings de button[type=submit], utilisation de attributes http://nytimes.github.io/backbone.stickit/#attribute-and-property-bindings/attributes
              * on tente avec observer : placeId. Pas bon car null = falsy, il nous faut justement le contraire. Équivalent conceptuel des computed de Knockout
              * création dans check\\_in\\_ux de initialize : checkCheckinable, exécution immédiate, écoute du on change du model
              * update du observe pour écouter checkInForbidden
              * vérifier dans l'interface : OFF par défaut, sélection = ON, recherche = OFF. Click sur bouton = validation du formulaire


              submit : récupération des infos du resto

              * ajout dans events submit checkIn, création checkIn
              * fonction checkIn : preventDefault
              * vérification de checkInForbidden => return
              * récupération des infos : faire trouver _.findWhere(this.model.get('places'), { id: this.model.get('placeId') });
              * console.log des infos de checkIn. Rajouter userName (require lib/notifications) et comment (dans le model grâce au binding bi-directionnel sur les éléments de formulaire http://nytimes.github.io/backbone.stickit/#form-element-bindings-and-contenteditable)
              * désélection et suppression du commentaire via modèle (placeId:null et comment:'')

            </aside>
          </section>
          <section id="spa-backbone-model">
            <h1>Backbone.Model</h1>

            <p>On accède par <code>get</code> et <code>set</code> aux attributs</p>
            <p>Gère les <em>dirties</em> (attributs modifiés), le <code>isNew()</code>, et un minimum de validation (mais plein de plugins), et <code>toJSON()</code></p>
            <p>Des plugins pour les relations entre modèles, etc.</p>
            <p>Événements <code>change</code> et <code>change:<em>attribute</em></code>, <code>invalid</code>, <code>request</code>, <code>error</code>, <code>sync</code> et <code>destroy</code>.</p>
            <p>Pré-intègre plusieurs méthodes cool d’Underscore : <code>pairs()</code>, <code>pick()</code>, <code>omit()</code>, <code>keys()</code>, <code>values()</code> et <code>invert()</code>.</p>

            <pre><code data-trim data-noescape class="javascript" data-file="models/check_in.js">
          module.exports = <u>Backbone.Model</u>.extend({
          // …
          });
            </code></pre>
            <aside class="notes" data-markdown>
              * request, sync, error : lors des synchros serveur
              * isNew : pas sauvé sur le serveur (absence de id, qui est le machin renvoyé par le serveur)
              * pick et omit : filtres sur des noms de clé
              * keys, values, pairs ( [ [key1, value1], [key2, value2] … ] ) , invert : les valeurs deviennent les clés
              * montrer models/check_in.js : ooooh, c'est vide. On pourrait y ajouter un validate, un defaults, un initialize, comme dans check_in_ux.js

            </aside>
          </section>

          <section id="spa-backbone-collection">
            <h1>Backbone.Collection</h1>

            <p>Liste de modèles, souvent de même type indiqué par <code>model</code>.</p>
            <p>Clé primaire par défaut des modèles : <code>id</code>.</p>
            <p>Ordre naturel personnalisable.</p>
            <p>Événements <code>add</code>, <code>remove</code>, <code>sort</code> et <code>reset</code>. Ceux des modèles remontent sur la collection aussi (<em>bubbling</em>).</p>
            <p>Pré-intègre plein de méthodes cool d’Underscore, dont <code>each</code>, <code>map</code>, <code>find</code>/<code>filter</code>/<code>findWhere</code>/<code>where</code>, <code>all</code>, <code>any</code>, <code>invoke</code>, <code>pluck</code>…</p>

            <pre><code data-trim data-noescape class="javascript" data-file="models/collection.js">
          module.exports = <u>Backbone.Collection</u>.extend({
          model: require('./check_in')
          });
            </code></pre>
            <aside class="notes" data-markdown>
              * intérêt de définir un modèle type par collection : un simple hash va convertir dans la bonne instance de modèle
              * un changement sur un objet en particulier fait remonter "change" au niveau de la collection
              * également .toJSON, get/att, push/pop, unshift/shift
              * pluck : réupération d'un attribut en particulier, mis dans un tableau
              * juste montrer models/collection.js

            </aside>
          </section>

          <section id="spa-persistence">
            <h1>La persistance</h1>

            <p>On va se créer une collection de check-ins, et y ajouter nos objets soigneusement définis.</p>

            <pre><code data-trim data-noescape class="javascript" data-file="lib/persistence.js">
          var CheckInsCollection = require('models/collection');
          var <u>collection</u> = new CheckInsCollection();

          function addCheckIn(checkIn) {
          checkIn.key = checkIn.key || Date.now();
          <u>collection.add</u>(checkIn);
          }

          <u>exports.addCheckIn</u> = addCheckIn;
            </code></pre>

            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
          var <u>store</u> = require('lib/persistence');
          // …
          checkIn: function(e) {
          // …
          <u>store.addCheckIn</u>({ … });
          },
            </code></pre>
            <aside class="notes" data-markdown>
              * but sauver notre checking sur le serveur
              * création app/lib/persistence.js
              * * require backbone, fonction addCheckin avec un console(checkIn), exports
              * * check_in_view : store = require lib/persistence, store.addCheckin(checkIn)
              * * vérification dans la console, plomberie OK, on ferme check_in_view
              * require de collection, instanciation, génération de .key, puis collection.add . Montrer que console.log(collection.toJSON()); ajoute bien des models à chaque clic
              * OK, mais à chaque reload, on repart de 0

            </aside>
          </section>

          <section id="spa-rest-json">
            <h1>REST + JSON</h1>

            <p>Le couple gagnant du Web des APIs, et celui que Backbone prend en charge par défaut.</p>

            <table class="table smaller">
              <thead>
                <tr>
                  <th>Méthode</th>
                  <th>URL</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><code>GET</code></td>
                  <td><code>/checkins</code></td>
                  <td>List</td>
                </tr>
                <tr>
                  <td><code>POST</code></td>
                  <td><code>/checkins</code></td>
                  <td><strong>C</strong>reate</td>
                </tr>
                <tr>
                  <td><code>GET</code></td>
                  <td><code>/checkins/&lt;key&gt;</code></td>
                  <td><strong>R</strong>ead</td>
                </tr>
                <tr>
                  <td><code>PUT</code>/<code>PATCH</code></td>
                  <td><code>/checkins/&lt;key&gt;</code></td>
                  <td><strong>U</strong>pdate</td>
                </tr>
                <tr>
                  <td><code>DELETE</code></td>
                  <td><code>/checkins/&lt;key&gt;</code></td>
                  <td><strong>D</strong>estroy</td>
                </tr>
              </tbody>
            </table>

            <pre><code data-trim data-noescape class="javascript" data-file="models/collection.js">
          model: require('./check_in')<u>,
          url: '/checkins'</u>
            </code></pre>

            <pre><code data-trim data-noescape class="javascript" data-file="lib/persistence.js">
          function addCheckIn(checkIn) {
          collection.<u>create</u>(checkIn); // add + save
          }
            </code></pre>
            <aside class="notes" data-markdown>
              * ça change de SOAP hein ?
              * rappel des codes principaux : 200, 201 created, 301, 302, 304 (not modified), 404, 403/401, 418 (teapot)
              * pas tout le monde a implémenté PATCH (qui permettait d'envoyer juste le delta des modifications) donc plutôt PUT qui envoie l'objet complet
              * models/collection.js : ajout de url : '/checkins'
              * persistence : remplacer .add par .create
              * montrer POST + code 201 + contenu id:1
              * expliquer l'implémentation REST de jst-server.coffee
              * * le tri sur key (qui est le timestamp)
              * * 201 + réponse + génération de l'id côté serveur
              * * :id en 200 ou 404
              * création et export de getCheckIns (return collection.toJSON) . test : après ajout exécuter require('lib/persistence').getCheckIns() dans la console (mais pas ceux du serveur)
              * création et exécution de syncPending, avec collection.fetch( reset true) , retester dans la console : on a bien a liste des checkins du serveur
            </aside>
          </section>
        </section>

        <section id="next-day">
          <h1>À suivre…</h1>

          <h3>Coder la suite de la SPA</h3>

          <ul>
            <li>Online/offline</li>
            <li>Stockage local</li>
            <li>Web sockets</li>
            <li>Tests</li>
          </ul>

          <h3>À <span data-marker="next-day-name">demain</span>&nbsp;!</h3>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });
    </script>
  </body>
</html>
